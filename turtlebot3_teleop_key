#!/usr/bin/env python

# Copyright (c) 2020, Yanbo Wang,Haolun Shan,Zechuan Duan KCL.
import time
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Illuminance
from sensor_msgs.msg import LaserScan
import sys, select, os

if os.name == 'nt':
    import msvcrt
else:
    import tty, termios

preTime = 0
left = 0  # Left  Light Senor value
right = 0  # Right Light Senor value
e = """
Communications Failed
"""


# Get Right Light Sensor value
def callbackone(data):
    global right
    right = data.illuminance


# Get Right Light Sensor value
def callbacktwo(data):
    global left
    left = data.illuminance


# Get Laser Scan value
def callLaser(data):
    global distance
    distance = data.ranges

def moveFront(twist,pub):
    twist.linear.x = target_linear_vel;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)
    rospy.sleep(9.3)

    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)


def moveBack(twist, pub):
    twist.linear.x = -target_linear_vel;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)
    rospy.sleep(9.3)

    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)


def moveRight(twist, pub):
    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.075;

    pub.publish(twist)
    rospy.sleep(10)

    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)
def moveleft(twist, pub):
    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0;
    twist.angular.y = 0.0;
    twist.angular.z = -0.075;

    pub.publish(twist)
    rospy.sleep(10)

    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;



    pub.publish(twist)

# Main function, include line follow and avoid obstacle
if __name__ == "__main__":
    if os.name != 'nt':
        settings = termios.tcgetattr(sys.stdin)

    rospy.init_node('topic_subscriber')
    pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
    distance = []

    Kp = 0.002  # Kp of Line Follow
    Kd = 0.00009  # Kd of Line Follow
    Tp = 0.07  # Initial line velocity
    prevErr = 0  # Previous Error
    pretime = 0
    isObstacle = False  # Whether start avoiding obstacle
    start = False  # Whether leave line and avoid obstacle

    try:
        # Main loop
        while(1):
            # Subscribe sensors
            sub = rospy.Subscriber('/light_sensor_plugin/lightSensor', Illuminance, callbackone)
            sub2 = rospy.Subscriber('/light_sensor_plugin/leftLightSensor', Illuminance, callbacktwo)
            sub4 = rospy.Subscriber("/scan", LaserScan, callLaser)

            # Give a initial linear velocity and angular velocity
            target_linear_vel = 0.01
            #print(preTime)
            # print(rospy.Time.now())
            # publish the angular velocity and linear velocity of the waffle-pi
            twist = Twist()

            moveRight(twist,pub)
            moveleft(twist,pub)





    except:
        print(e)

    finally:
        twist = Twist()
        twist.linear.x = 0.0;
        twist.linear.y = 0.0;
        twist.linear.z = 0.0
        twist.angular.x = 0.0;
        twist.angular.y = 0.0;
        twist.angular.z = 0.0
        pub.publish(twist)

    if os.name != 'nt':
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)