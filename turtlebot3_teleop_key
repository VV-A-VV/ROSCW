#!/usr/bin/env python

# Copyright (c) 2020, Yanbo Wang,Haolun Shan,Zechuan Duan KCL.
import math
import threading
import rospy
import tf
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Illuminance
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
import sys, select, os

if os.name == 'nt':
    import msvcrt
else:
    import tty, termios
poseRead = 0
yaw = 0
preTime = 0
left = 0  # Left  Light Senor value
right = 0  # Right Light Senor value
grey = False
white = True
targetx = 1.1148569
targety = -1.492956
targetyaw = 0.743460
pose_x = 0
pose_y = 0
x_direction_force = 0
y_direction_force = 0
distance = ["inf"]*360
e = """
Communications Failed
"""
pi = 3.1415926535


# Get Right Light Sensor value
def callbackone(data):
    global right
    right = data.illuminance


# Get Right Light Sensor value
def callbacktwo(data):
    global left
    left = data.illuminance


def thread_job():
    rospy.spin()


# Get Laser Scan value
def callLaser(data):
    global distance
    distance = data.ranges


# x is the distance of each direction
# y is the degree of obstacle
# the number of y is increasing from left to right(0 to 360)

def calculation(distance):
    global degree
    global x_direction_force
    global y_direction_force
    x_direction_force = 0
    y_direction_force = 0
    for i in range(360):
        if (distance[i] == "inf" or distance[i] >1 or i>60 and i<300 ):
            x_direction_force += 0
            y_direction_force += 0
        else:
            y_direction_force += 1/(distance[i] *distance[i])* math.sin(math.radians(i))
            x_direction_force += 1/(distance[i] *distance[i]) * math.cos(math.radians(i))
    if(y_direction_force == 0):
        degree = 0
    else:
        degree = math.atan(y_direction_force / x_direction_force)
    z_forces = math.sqrt(x_direction_force * x_direction_force + y_direction_force * y_direction_force)

def moveFront(twist, pub):
    print("movefront")
    twist.linear.x = target_linear_vel;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;
    pub.publish(twist)

    rospy.sleep(4.5)
    twist.linear.x = 0.0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;

    pub.publish(twist)


def moveBack(twist, pub):
    twist.linear.x = -target_linear_vel;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)
    rospy.sleep(9.3)

    twist.linear.x = 0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0;

    pub.publish(twist)


# def moveRight(twist, pub):
#     twist.linear.x = 0;
#     twist.linear.y = 0.0;
#     twist.linear.z = 0.0
#     twist.angular.x = 0.0;
#     twist.angular.y = 0.0;
#     twist.angular.z = 0.075;
#
#     pub.publish(twist)
#     rospy.sleep(10)
#
#     twist.linear.x = 0;
#     twist.linear.y = 0.0;
#     twist.linear.z = 0.0
#     twist.angular.x = 0.0;
#     twist.angular.y = 0.0;
#     twist.angular.z = 0;
#
#     pub.publish(twist)
#
#
# def moveleft(twist, pub):
#     twist.linear.x = 0;
#     twist.linear.y = 0.0;
#     twist.linear.z = 0.0
#     twist.angular.x = 0;
#     twist.angular.y = 0.0;
#     twist.angular.z = -0.075;
#
#     pub.publish(twist)
#     rospy.sleep(10)
#
#     twist.linear.x = 0;
#     twist.linear.y = 0.0;
#     twist.linear.z = 0.0
#     twist.angular.x = 0.0;
#     twist.angular.y = 0.0;
#     twist.angular.z = 0.0;
#
#     pub.publish(twist)


def nomalization(estimation):
    s = sum(estimation)
    for i in range(len(estimation)):
        estimation[i] = estimation[i] / s
    return estimation


def postPro(list1, list2):
    list1.insert(0, 0)
    list1.pop()
    for i in range(len(list1)):
        list1[i] = list1[i] * list2[i]
    return list1


def postPro_back(list1, list2):
    list1.insert(12, 0)
    list1.pop(0)
    for i in range(len(list1)):
        list1[i] = list1[i] * list2[i]
    return list1


def callOdom(data):
    global poseRead
    global yaw
    global pose_x
    global pose_y
    poseRead = data.pose
    pose_x = poseRead.pose.position.x
    pose_y = poseRead.pose.position.y
    quaternion = (
        poseRead.pose.orientation.x,
        poseRead.pose.orientation.y,
        poseRead.pose.orientation.z,
        poseRead.pose.orientation.w)
    euler = tf.transformations.euler_from_quaternion(quaternion)
    yaw = euler[2]


# Main function, include line follow and avoid obstacle
if __name__ == "__main__":
    if os.name != 'nt':
        settings = termios.tcgetattr(sys.stdin)
    rospy.init_node('topic_subscriber', anonymous=False)
    pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
    lognow = []
    target_linear_vel = 0.01
    Kangular = 0.002
    Vangular = 0
    isObstacle = False  # Whether start avoiding obstacle
    start = False  # Whether leave line and avoid obstacle
    sensorWork = 0.9
    Estimation = [0.1] * 26
    White = [0, 0.066, 0.066, 0.001, 0.066, 0.066, 0.066, 0.001, 0.001, 0.066, 0.066, 0.001, 0.066, 0.066, 0.066, 0.001,
            0.001, 0.066, 0.066, 0.066, 0.001, 0.001, 0.066, 0.066, 0.001, 0]
    Grey = [0, 0.001, 0.001, 0.111, 0.001, 0.001, 0.001, 0.111, 0.111, 0.001, 0.001, 0.111, 0.001, 0.001, 0.001, 0.111,
             0.111, 0.001, 0.001, 0.001, 0.111, 0.111, 0.001, 0.001, 0.111, 0]
    # outBound = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
    grey = True
    white = False
    map = [white,grey,grey,white,white,grey,grey,grey,white,white,grey,grey,grey,white,grey,grey,white,white,grey,grey,grey,white,grey,grey]
    counter = 0
    rospy.Subscriber("/scan", LaserScan, callLaser)
    rospy.Subscriber("/odom", Odometry, callOdom)
    rospy.Subscriber('/light_sensor_plugin/lightSensor', Illuminance, callbackone)
    rospy.Subscriber('/light_sensor_plugin/leftLightSensor', Illuminance, callbacktwo)
    distance_x = 999999
    distance_y = 1
    task = 2
    # Main loop
    while (1):
        if (task == 1):
            twist = Twist()
            print(left, right)
            moveFront(twist, pub)

            if (110 <= left and left <= 163):  # grey
                print("grey")
                lognow.append(grey)
                Estimation = postPro(Estimation, Grey)
            elif (228 <= left and left <= 260):  # grey
                print("white")
                lognow.append(white)
                Estimation = postPro(Estimation, White)

            else:
                print("car die")
                print(left)
                rospy.sleep(1)
                continue

            maploc = [0]*24
            print("lognow::")
            print(lognow)
            msize = len(map)
            success = 0
            successnow = False
            sucposition = 0
            for i in range(0, msize):
                for y in range(0, (len(lognow))):

                    if ((i + y) > 23):
                        successnow = False
                        break
                    if (map[i + y] == lognow[y]):
                        successnow = True
                    else:
                        successnow = False
                        break
                if (successnow == False):
                    successnow = True
                elif (successnow == True):
                    pos = i + len(lognow) - 1
                    print("pos:")
                    print(pos)
                    maploc[pos] = 1.0
                    supposition = pos
                    success = success + 1
                    print(success)
            if(success==1) :
                print('we are in the position')
                print(supposition)
                task+=1
            else:
                print("probability:")
                for i in range(0,msize):
                   print(i)
                   print(maploc[i]/success)
                   print(' ')

        if(task == 2):
            calculation(distance)
            distance_x = targetx - pose_x
            distance_y = targety - pose_y
            beta = math.atan(distance_y / distance_x)
            alpha1 = beta - yaw
            alpha2 = beta - yaw + pi
            if(abs(alpha1) < abs(alpha2) ):
                alpha = alpha1
            else:
                alpha = alpha2
            if(alpha<0):
                Vangular = -math.sqrt(alpha*alpha)*0.1
            if(alpha>0):
                Vangular = math.sqrt(alpha*alpha)*0.1


            if(abs(distance_y)>0.3 or abs(distance_x)>0.3):
                if(y_direction_force>0):
                    Vangular -= y_direction_force * 0.0014
                    if (Vangular < -0.1):
                        Vangular = -0.1
                if (y_direction_force < 0):
                    Vangular -= y_direction_force * 0.0014
                    if (Vangular > 0.1):
                        Vangular = 0.1

                if(alpha< -1.4):
                    Vangular = -0.05
                if(alpha > 1.4):
                    Vangular = 0.05
            twist = Twist()
            if(abs(distance_y)<0.1 and abs(distance_x)<0.1):
                twist.linear.x = 0.1*math.sqrt(abs(distance_y)*abs(distance_y)+abs(distance_x)*abs(distance_x))
                counter +=1
                print("A")
                rospy.sleep(0.2)
                if(counter== 100):
                    twist.linear.x = 0.0;
                    twist.linear.y = 0.0;
                    twist.linear.z = 0.0;
                    twist.angular.x = 0.0;
                    twist.angular.y = 0.0;
                    twist.angular.z =Vangular;
                    counter =0
                    pub.publish(twist)
                    print("while one end")

                    task += 1

            else:
                twist.linear.x = 0.03;

            twist.linear.y = 0.0;
            twist.linear.z = 0.0;
            twist.angular.x = 0.0;
            twist.angular.y = 0.0;
            twist.angular.z = Vangular;
            print(Vangular)
            pub.publish(twist)

        if(task == 3):
            angv =0
            twist = Twist()
            ang=targetyaw-yaw
            print(ang)
            if(abs(ang)<0.05):
                twist = Twist()
                twist.linear.x = 0.05;
                twist.linear.y = 0.0;
                twist.linear.z = 0.0;
                twist.angular.x = 0.0;
                twist.angular.y = 0.0;
                twist.angular.z = 0.0;
                pub.publish(twist)
            else:
                twist = Twist()
                twist.linear.x = 0.0;
                twist.linear.y = 0.0;
                twist.linear.z = 0.0;
                twist.angular.x = 0.0;
                twist.angular.y = 0.0;
                twist.angular.z = ang*0.06;
                pub.publish(twist)
            rospy.sleep(0.2)





    #    137min 163max(grey)             228min 246max(white)
    #     twist = Twist()


           # publish the angular velocity and linear velocity of the waffle-pi
           #  137min 163max(grey)             228min 246max(white)

    if os.name != 'nt':
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)